import Init.Omega
import Chess.SemanticSlidingGeometryLemmas

namespace Chess
namespace Rules

open Movement

/-!
Path-clear correctness for sliding targets.

For rook/bishop/queen moves generated by `Rules.slidingTargets`, prove that the
intermediate squares (as enumerated by `Movement.squaresBetween`) are empty,
so `Rules.pathClear` is always `true` for those moves.
-/

def rayEmptyUpTo (board : Board) (src : Square) (df dr : Int) (processed : Nat) : Prop :=
  ∀ t, 1 ≤ t → t ≤ processed →
    ∀ sq,
      Movement.squareFromInts (src.fileInt + df * (t : Int)) (src.rankInt + dr * (t : Int)) = some sq →
        board sq = none

theorem rayEmptyUpTo_mono
    {board : Board} {src : Square} {df dr : Int} {a b : Nat}
    (h : rayEmptyUpTo board src df dr b) (hab : a ≤ b) :
    rayEmptyUpTo board src df dr a := by
  intro t ht1 hta sq hSq
  exact h t ht1 (Nat.le_trans hta hab) sq hSq

theorem isRookMove_not_isDiagonal {src tgt : Square} (hRook : Movement.isRookMove src tgt) :
    ¬ Movement.isDiagonal src tgt := by
  intro hDiag
  have hLine := hRook.2
  rcases hDiag with ⟨_, hAbs⟩
  have hStraight : Movement.fileDiff src tgt = 0 ∨ Movement.rankDiff src tgt = 0 :=
    Movement.rook_move_straight hRook
  cases hStraight with
  | inl hfd0 =>
      have hrdne : Movement.rankDiff src tgt ≠ 0 := by
        cases hLine with
        | inl hcase => exact hcase.2
        | inr hcase =>
            exfalso
            exact hcase.2 hfd0
      have hrabs0 : Movement.absInt (Movement.rankDiff src tgt) = 0 := by
        simpa [hfd0, Movement.absInt] using congrArg id (Eq.symm hAbs)
      have hr0 : Movement.rankDiff src tgt = 0 := by
        by_cases hr : 0 ≤ Movement.rankDiff src tgt
        · simpa [Movement.absInt, hr] using hrabs0
        · have : -Movement.rankDiff src tgt = 0 := by
            simpa [Movement.absInt, hr] using hrabs0
          omega
      exact hrdne hr0
  | inr hrd0 =>
      have hfdne : Movement.fileDiff src tgt ≠ 0 := by
        cases hLine with
        | inl hcase =>
            exfalso
            exact hcase.2 hrd0
        | inr hcase => exact hcase.2
      have hfabs0 : Movement.absInt (Movement.fileDiff src tgt) = 0 := by
        simpa [hrd0, Movement.absInt] using hAbs
      have hf0 : Movement.fileDiff src tgt = 0 := by
        by_cases hf : 0 ≤ Movement.fileDiff src tgt
        · simpa [Movement.absInt, hf] using hfabs0
        · have : -Movement.fileDiff src tgt = 0 := by
            simpa [Movement.absInt, hf] using hfabs0
          omega
      exact hfdne hf0

theorem pathClear_of_rayEmptyUpTo_rookDelta
    (board : Board) (src tgt : Square) (df dr : Int) (k : Nat)
    (hSq :
      Movement.squareFromInts (src.fileInt + df * (k : Int)) (src.rankInt + dr * (k : Int)) = some tgt)
    (hkPos : 0 < k)
    (hDelta : isRookDelta (df, dr))
    (hRay : rayEmptyUpTo board src df dr (k - 1)) :
    Rules.pathClear board src tgt = true := by
  refine (Rules.pathClear_eq_true_iff board src tgt).2 ?_
  intro sq hMem
  have hRook : Movement.isRookMove src tgt :=
    isRookMove_of_coords (src := src) (tgt := tgt) (k := k) (df := df) (dr := dr) (by
      simpa using hSq) hkPos hDelta
  have hNotDiag : ¬ Movement.isDiagonal src tgt := isRookMove_not_isDiagonal hRook
  -- Unfold `squaresBetween` on the rook branch; `simp` exposes the index witness.
  have hMem' := hMem
  unfold Movement.squaresBetween at hMem'
  simp [hNotDiag, hRook] at hMem'
  rcases hMem' with ⟨_hStepsGt1, idx, hIdxLt, hSqIdx⟩
  -- `idx` corresponds to offset `t = idx + 1`.
  let t : Nat := idx + 1
  have ht1 : 1 ≤ t := by simp [t]
  -- Show `t ≤ k - 1` by rewriting the computed `steps` to `k`.
  have hFile :
      tgt.fileInt = src.fileInt + df * (k : Int) :=
    Movement.squareFromInts_fileInt (src.fileInt + df * (k : Int)) (src.rankInt + dr * (k : Int)) tgt hSq
  have hRank :
      tgt.rankInt = src.rankInt + dr * (k : Int) :=
    Movement.squareFromInts_rankInt (src.fileInt + df * (k : Int)) (src.rankInt + dr * (k : Int)) tgt hSq
  have hfd : Movement.fileDiff src tgt = -(df * (k : Int)) := by
    unfold Movement.fileDiff
    simp [hFile]
    omega
  have hrd : Movement.rankDiff src tgt = -(dr * (k : Int)) := by
    unfold Movement.rankDiff
    simp [hRank]
    omega
  have hSteps : (Movement.fileDiff src tgt).natAbs + (Movement.rankDiff src tgt).natAbs = k := by
    -- Case analysis on the rook delta to normalize to `±k` and `0`.
    cases hDelta with
    | inl h10 =>
        rcases h10 with ⟨hdf, hdr⟩
        subst hdf; subst hdr
        simp [hfd, hrd, Int.natAbs_neg, Nat.ne_of_gt hkPos]
    | inr hRest =>
        cases hRest with
        | inl hn10 =>
            rcases hn10 with ⟨hdf, hdr⟩
            subst hdf; subst hdr
            simp [hfd, hrd]
        | inr hRest2 =>
            cases hRest2 with
            | inl h01 =>
                rcases h01 with ⟨hdf, hdr⟩
                subst hdf; subst hdr
                simp [hfd, hrd, Int.natAbs_neg, Nat.ne_of_gt hkPos]
            | inr h0n1 =>
                rcases h0n1 with ⟨hdf, hdr⟩
                subst hdf; subst hdr
                simp [hfd, hrd]
  have htLe : t ≤ k - 1 := by
    have hIdxLt' : idx < k - 1 := by
      simpa [hSteps] using hIdxLt
    exact Nat.succ_le_of_lt hIdxLt'
  -- Rewrite the step directions in `squaresBetween` to `df/dr`.
  have hStepFile : Movement.signInt (-Movement.fileDiff src tgt) = df := by
    cases hDelta with
    | inl h10 =>
        rcases h10 with ⟨hdf, hdr⟩
        subst hdf; subst hdr
        have : -Movement.fileDiff src tgt = (k : Int) := by simp [hfd]
        simpa [this] using Movement.signInt_ofNat_pos k hkPos
    | inr hRest =>
        cases hRest with
        | inl hn10 =>
            rcases hn10 with ⟨hdf, hdr⟩
            subst hdf; subst hdr
            have : -Movement.fileDiff src tgt = -(k : Int) := by simp [hfd]
            simpa [this] using Movement.signInt_neg_ofNat_pos k hkPos
        | inr hRest2 =>
            cases hRest2 with
            | inl h01 =>
                rcases h01 with ⟨hdf, hdr⟩
                subst hdf; subst hdr
                simp [Movement.signInt, hfd]
            | inr h0n1 =>
                rcases h0n1 with ⟨hdf, hdr⟩
                subst hdf; subst hdr
                simp [Movement.signInt, hfd]
  have hStepRank : Movement.signInt (-Movement.rankDiff src tgt) = dr := by
    cases hDelta with
    | inl h10 =>
        rcases h10 with ⟨hdf, hdr⟩
        subst hdf; subst hdr
        simp [Movement.signInt, hrd]
    | inr hRest =>
        cases hRest with
        | inl hn10 =>
            rcases hn10 with ⟨hdf, hdr⟩
            subst hdf; subst hdr
            simp [Movement.signInt, hrd]
        | inr hRest2 =>
            cases hRest2 with
            | inl h01 =>
                rcases h01 with ⟨hdf, hdr⟩
                subst hdf; subst hdr
                have : -Movement.rankDiff src tgt = (k : Int) := by simp [hrd]
                simpa [this] using Movement.signInt_ofNat_pos k hkPos
            | inr h0n1 =>
                rcases h0n1 with ⟨hdf, hdr⟩
                subst hdf; subst hdr
                have : -Movement.rankDiff src tgt = -(k : Int) := by simp [hrd]
                simpa [this] using Movement.signInt_neg_ofNat_pos k hkPos
  have hSqRay :
      Movement.squareFromInts (src.fileInt + df * (t : Int)) (src.rankInt + dr * (t : Int)) = some sq := by
    simpa [t, hStepFile, hStepRank] using hSqIdx
  exact hRay t ht1 htLe sq hSqRay

theorem pathClear_of_rayEmptyUpTo_bishopDelta
    (board : Board) (src tgt : Square) (df dr : Int) (k : Nat)
    (hSq :
      Movement.squareFromInts (src.fileInt + df * (k : Int)) (src.rankInt + dr * (k : Int)) = some tgt)
    (hkPos : 0 < k)
    (hDelta : isBishopDelta (df, dr))
    (hRay : rayEmptyUpTo board src df dr (k - 1)) :
    Rules.pathClear board src tgt = true := by
  refine (Rules.pathClear_eq_true_iff board src tgt).2 ?_
  intro sq hMem
  have hDiag : Movement.isDiagonal src tgt :=
    isDiagonal_of_coords (src := src) (tgt := tgt) (k := k) (df := df) (dr := dr) (by
      simpa using hSq) hkPos hDelta
  have hMem' := hMem
  unfold Movement.squaresBetween at hMem'
  simp [hDiag] at hMem'
  rcases hMem' with ⟨_hStepsGt1, idx, hIdxLt, hSqIdx⟩
  let t : Nat := idx + 1
  have ht1 : 1 ≤ t := by simp [t]
  have hFile :
      tgt.fileInt = src.fileInt + df * (k : Int) :=
    Movement.squareFromInts_fileInt (src.fileInt + df * (k : Int)) (src.rankInt + dr * (k : Int)) tgt hSq
  have hRank :
      tgt.rankInt = src.rankInt + dr * (k : Int) :=
    Movement.squareFromInts_rankInt (src.fileInt + df * (k : Int)) (src.rankInt + dr * (k : Int)) tgt hSq
  have hfd : Movement.fileDiff src tgt = -(df * (k : Int)) := by
    unfold Movement.fileDiff
    simp [hFile]
    omega
  have hSteps : (Movement.fileDiff src tgt).natAbs = k := by
    cases hDelta with
    | inl h11 =>
        rcases h11 with ⟨hdf, _hdr⟩
        subst hdf
        simp [hfd, Int.natAbs_neg, Nat.ne_of_gt hkPos]
    | inr hRest =>
        cases hRest with
        | inl hn1n1 =>
            rcases hn1n1 with ⟨hdf, _hdr⟩
            subst hdf
            simp [hfd]
        | inr hRest2 =>
            cases hRest2 with
            | inl h1n1 =>
                rcases h1n1 with ⟨hdf, _hdr⟩
                subst hdf
                simp [hfd, Int.natAbs_neg, Nat.ne_of_gt hkPos]
            | inr hn11 =>
                rcases hn11 with ⟨hdf, _hdr⟩
                subst hdf
                simp [hfd]
  have htLe : t ≤ k - 1 := by
    have hIdxLt' : idx < k - 1 := by
      simpa [hSteps] using hIdxLt
    exact Nat.succ_le_of_lt hIdxLt'
  have hrd : Movement.rankDiff src tgt = -(dr * (k : Int)) := by
    unfold Movement.rankDiff
    simp [hRank]
    omega
  have hStepFile : Movement.signInt (-Movement.fileDiff src tgt) = df := by
    cases hDelta with
    | inl h11 =>
        rcases h11 with ⟨hdf, hdr⟩
        subst hdf; subst hdr
        have : -Movement.fileDiff src tgt = (k : Int) := by simp [hfd]
        simpa [this] using Movement.signInt_ofNat_pos k hkPos
    | inr hRest =>
        cases hRest with
        | inl hn1n1 =>
            rcases hn1n1 with ⟨hdf, hdr⟩
            subst hdf; subst hdr
            have : -Movement.fileDiff src tgt = -(k : Int) := by simp [hfd]
            simpa [this] using Movement.signInt_neg_ofNat_pos k hkPos
        | inr hRest2 =>
            cases hRest2 with
            | inl h1n1 =>
                rcases h1n1 with ⟨hdf, hdr⟩
                subst hdf; subst hdr
                have : -Movement.fileDiff src tgt = (k : Int) := by simp [hfd]
                simpa [this] using Movement.signInt_ofNat_pos k hkPos
            | inr hn11 =>
                rcases hn11 with ⟨hdf, hdr⟩
                subst hdf; subst hdr
                have : -Movement.fileDiff src tgt = -(k : Int) := by simp [hfd]
                simpa [this] using Movement.signInt_neg_ofNat_pos k hkPos
  have hStepRank : Movement.signInt (-Movement.rankDiff src tgt) = dr := by
    cases hDelta with
    | inl h11 =>
        rcases h11 with ⟨hdf, hdr⟩
        subst hdf; subst hdr
        have : -Movement.rankDiff src tgt = (k : Int) := by simp [hrd]
        simpa [this] using Movement.signInt_ofNat_pos k hkPos
    | inr hRest =>
        cases hRest with
        | inl hn1n1 =>
            rcases hn1n1 with ⟨hdf, hdr⟩
            subst hdf; subst hdr
            have : -Movement.rankDiff src tgt = -(k : Int) := by simp [hrd]
            simpa [this] using Movement.signInt_neg_ofNat_pos k hkPos
        | inr hRest2 =>
            cases hRest2 with
            | inl h1n1 =>
                rcases h1n1 with ⟨hdf, hdr⟩
                subst hdf; subst hdr
                have : -Movement.rankDiff src tgt = -(k : Int) := by simp [hrd]
                simpa [this] using Movement.signInt_neg_ofNat_pos k hkPos
            | inr hn11 =>
                rcases hn11 with ⟨hdf, hdr⟩
                subst hdf; subst hdr
                have : -Movement.rankDiff src tgt = (k : Int) := by simp [hrd]
                simpa [this] using Movement.signInt_ofNat_pos k hkPos
  have hSqRay :
      Movement.squareFromInts (src.fileInt + df * (t : Int)) (src.rankInt + dr * (t : Int)) = some sq := by
    simpa [t, hStepFile, hStepRank] using hSqIdx
  exact hRay t ht1 htLe sq hSqRay

theorem slidingTargets_walk_mem_pathClear
    (src : Square) (p : Piece) (board : Board) (color : Color) (maxStep : Nat)
    (df dr : Int) (hDelta : isQueenDelta (df, dr)) :
    ∀ (step : Nat) (acc : List Move) (m : Move),
      step ≤ maxStep →
      rayEmptyUpTo board src df dr (maxStep - step) →
      (∀ x ∈ acc, Rules.pathClear board src x.toSq = true) →
      m ∈ Rules.slidingTargets.walk src p board color maxStep df dr step acc →
      Rules.pathClear board src m.toSq = true := by
  intro step
  induction step with
  | zero =>
      intro acc m _hLe _hRay hAcc hMem
      simp [Rules.slidingTargets.walk] at hMem
      exact hAcc m hMem
  | succ s ih =>
      intro acc m hLe hRay hAcc hMem
      have hMem' :
          m ∈
            match Movement.squareFromInts (src.fileInt + df * (maxStep - s : Nat))
                  (src.rankInt + dr * (maxStep - s : Nat)) with
            | none => acc
            | some target =>
                if Rules.isEmpty board target = true then
                  Rules.slidingTargets.walk src p board color maxStep df dr s
                    ({ piece := p, fromSq := src, toSq := target } :: acc)
                else if Rules.isEnemyNonKingAt board color target = true then
                  { piece := p, fromSq := src, toSq := target, isCapture := true } :: acc
                else acc := by
        simpa [Rules.slidingTargets.walk] using hMem
      revert hMem'
      cases hSq :
          Movement.squareFromInts (src.fileInt + df * (maxStep - s : Nat))
              (src.rankInt + dr * (maxStep - s : Nat)) with
      | none =>
          intro hMem'
          exact hAcc m hMem'
      | some target =>
          intro hMem'
          have hslt : s < maxStep := Nat.lt_of_succ_le hLe
          have hkPos : 0 < maxStep - s := Nat.sub_pos_of_lt hslt
          have hRayPrev : rayEmptyUpTo board src df dr ((maxStep - s) - 1) := by
            -- `maxStep - succ s = (maxStep - s) - 1`.
            exact rayEmptyUpTo_mono (a := (maxStep - s) - 1) (b := maxStep - Nat.succ s) hRay (by omega)
          have hPathTarget : Rules.pathClear board src target = true := by
            cases hDelta with
            | inl hRook =>
                exact pathClear_of_rayEmptyUpTo_rookDelta board src target df dr (maxStep - s) (by
                  simpa using hSq) hkPos hRook hRayPrev
            | inr hBish =>
                exact pathClear_of_rayEmptyUpTo_bishopDelta board src target df dr (maxStep - s) (by
                  simpa using hSq) hkPos hBish hRayPrev
          by_cases hEmpty : Rules.isEmpty board target = true
          · -- Continue: extend the ray invariant with this empty square.
            have hRayNext : rayEmptyUpTo board src df dr (maxStep - s) := by
              intro t ht1 htLe sq hSqT
              by_cases hEq : t = maxStep - s
              · subst hEq
                have sqEq : sq = target := by
                  have hSqT' :
                      Movement.squareFromInts (src.fileInt + df * (maxStep - s : Nat))
                          (src.rankInt + dr * (maxStep - s : Nat)) =
                        some sq := hSqT
                  -- `hSq` and `hSqT'` share the same LHS.
                  exact (Option.some.inj (by simpa [hSq] using hSqT')).symm
                subst sqEq
                simpa [Rules.isEmpty] using hEmpty
              · have htLe' : t ≤ (maxStep - s) - 1 := by
                  have : t ≤ maxStep - s := htLe
                  have : t < maxStep - s := Nat.lt_of_le_of_ne this hEq
                  exact Nat.le_pred_of_lt this
                exact hRayPrev t ht1 htLe' sq hSqT
            have hAccNext :
                ∀ x ∈ ({ piece := p, fromSq := src, toSq := target } :: acc),
                  Rules.pathClear board src x.toSq = true := by
              intro x hx
              simp at hx
              rcases hx with rfl | hx
              · exact hPathTarget
              · exact hAcc x hx
            have hMemRec :
                m ∈ Rules.slidingTargets.walk src p board color maxStep df dr s
                  ({ piece := p, fromSq := src, toSq := target } :: acc) := by
              simpa [hSq, hEmpty] using hMem'
            exact ih ({ piece := p, fromSq := src, toSq := target } :: acc) m (by omega) hRayNext hAccNext hMemRec
          · by_cases hEnemy : Rules.isEnemyNonKingAt board color target = true
            · have hMemCons :
                  m = { piece := p, fromSq := src, toSq := target, isCapture := true } ∨ m ∈ acc := by
                simpa [hSq, hEmpty, hEnemy] using hMem'
              cases hMemCons with
              | inl hm =>
                  subst hm
                  exact hPathTarget
              | inr hm =>
                  exact hAcc m hm
            · have : m ∈ acc := by
                simpa [hSq, hEmpty, hEnemy] using hMem'
              exact hAcc m this

theorem mem_slidingTargets_pathClear
    (gs : GameState) (src : Square) (p : Piece) (deltas : List (Int × Int)) (m : Move)
    (hDeltas : ∀ d ∈ deltas, isQueenDelta d) :
    m ∈ Rules.slidingTargets gs src p deltas →
    Rules.pathClear gs.board src m.toSq = true := by
  revert m
  induction deltas with
  | nil =>
      intro m hMem
      cases (show False by simpa [Rules.slidingTargets] using hMem)
  | cons d rest ih =>
      intro m hMem
      rcases d with ⟨df, dr⟩
      have hDelta : isQueenDelta (df, dr) := hDeltas (df, dr) (by simp)
      let acc :=
        List.foldr
          (fun d acc =>
            match d with
            | (df, dr) => Rules.slidingTargets.walk src p gs.board p.color 7 df dr 7 acc)
          [] rest
      have hAccAll : ∀ x ∈ acc, Rules.pathClear gs.board src x.toSq = true := by
        intro x hx
        have hx' : x ∈ Rules.slidingTargets gs src p rest := by
          simpa [Rules.slidingTargets, acc] using hx
        have hDeltasRest : ∀ d ∈ rest, isQueenDelta d := by
          intro d hd
          exact hDeltas d (by simp [hd])
        exact ih hDeltasRest x hx'
      have hMem' : m ∈ Rules.slidingTargets.walk src p gs.board p.color 7 df dr 7 acc := by
        simpa [Rules.slidingTargets, List.foldr, acc] using hMem
      have hRay0 : rayEmptyUpTo gs.board src df dr (7 - 7) := by
        intro t ht1 ht0
        have : False := by omega
        cases this
      exact
        slidingTargets_walk_mem_pathClear src p gs.board p.color 7 df dr hDelta 7 acc m (by simp) hRay0 hAccAll hMem'

theorem mem_pieceTargets_rook_pathClear
    (gs : GameState) (src : Square) (p : Piece) (m : Move)
    (hRook : p.pieceType = PieceType.Rook) :
    m ∈ pieceTargets gs src p →
    Rules.pathClear gs.board src m.toSq = true := by
  intro hMem
  have hMem' :
      m ∈
        slidingTargets gs src p [(1, 0), (-1, 0), (0, 1), (0, -1)] := by
    simpa [pieceTargets, hRook] using hMem
  refine mem_slidingTargets_pathClear gs src p _ m ?_ hMem'
  intro d hd
  have hd' : d = (1, 0) ∨ d = (-1, 0) ∨ d = (0, 1) ∨ d = (0, -1) := by
    simpa using hd
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isRookDelta]
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isRookDelta]
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isRookDelta]
  · rcases hd' with rfl
    simp [isQueenDelta, isRookDelta]

theorem mem_pieceTargets_bishop_pathClear
    (gs : GameState) (src : Square) (p : Piece) (m : Move)
    (hBishop : p.pieceType = PieceType.Bishop) :
    m ∈ pieceTargets gs src p →
    Rules.pathClear gs.board src m.toSq = true := by
  intro hMem
  have hMem' :
      m ∈
        slidingTargets gs src p [(1, 1), (-1, -1), (1, -1), (-1, 1)] := by
    simpa [pieceTargets, hBishop] using hMem
  refine mem_slidingTargets_pathClear gs src p _ m ?_ hMem'
  intro d hd
  have hd' : d = (1, 1) ∨ d = (-1, -1) ∨ d = (1, -1) ∨ d = (-1, 1) := by
    simpa using hd
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isBishopDelta]
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isBishopDelta]
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isBishopDelta]
  · rcases hd' with rfl
    simp [isQueenDelta, isBishopDelta]

theorem mem_pieceTargets_queen_pathClear
    (gs : GameState) (src : Square) (p : Piece) (m : Move)
    (hQueen : p.pieceType = PieceType.Queen) :
    m ∈ pieceTargets gs src p →
    Rules.pathClear gs.board src m.toSq = true := by
  intro hMem
  have hMem' :
      m ∈
        slidingTargets gs src p
          [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)] := by
    simpa [pieceTargets, hQueen] using hMem
  refine mem_slidingTargets_pathClear gs src p _ m ?_ hMem'
  intro d hd
  have hd' :
      d = (1, 0) ∨ d = (-1, 0) ∨ d = (0, 1) ∨ d = (0, -1) ∨
      d = (1, 1) ∨ d = (-1, -1) ∨ d = (1, -1) ∨ d = (-1, 1) := by
    simpa using hd
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isRookDelta]
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isRookDelta]
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isRookDelta]
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isRookDelta]
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isBishopDelta]
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isBishopDelta]
  rcases hd' with rfl | hd'
  · simp [isQueenDelta, isBishopDelta]
  · rcases hd' with rfl
    simp [isQueenDelta, isBishopDelta]

end Rules
end Chess
