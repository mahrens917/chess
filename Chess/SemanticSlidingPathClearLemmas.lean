import Init.Omega
import Chess.SemanticSlidingGeometryLemmas

namespace Chess
namespace Rules

open Movement

-- ============================================================================
-- Path Clearance Proofs for Sliding Pieces
-- ============================================================================

-- These proofs show that moves generated by slidingTargets have clear paths.
-- The key insight is that the walk function only generates a move at offset K
-- if all squares at offsets 1..K-1 were empty (allowing the walk to continue).

-- Helper: The walk generates a move at offset K only if all earlier offsets were empty.
-- This is proved by analyzing the walk structure: at each offset j < K, either:
-- 1. squareFromInts returned none (edge case, rare)
-- 2. The square was empty, so the walk continued
-- If the square was non-empty, the walk would stop and not reach offset K.

-- Simpler formulation: prove path clearance by showing squaresBetween squares are empty
-- pathClear board src tgt = (squaresBetween src tgt).all (fun sq => board sq = none)

-- For a rook move, squaresBetween returns squares at offsets 1..K-1 where K = rookOffset.
-- These are exactly the squares the walk passed through to reach offset K.

-- TODO: The full proof requires a complex induction on offset that tracks
-- "all previous offsets had empty squares". For now, we document the approach
-- and mark with sorry.

-- The semantic property is: For a move m generated by pieceTargets at offset K,
-- all squares at offsets 1..K-1 (that exist) are empty. This is because:
-- 1. The walk processes offsets 1, 2, ..., K in order
-- 2. At each offset j, if the square exists and is non-empty, the walk stops
-- 3. Since the walk reached offset K, all offsets 1..K-1 were "passable"
-- 4. "Passable" means either squareFromInts = none or isEmpty = true
-- 5. squaresBetween filters to only existing squares, so all are isEmpty = true

-- Helper: rook deltas are rook deltas
private theorem rook_deltas_are_rook (d : Int × Int)
    (hMem : d ∈ [(1, 0), (-1, 0), (0, 1), (0, -1)]) :
    isRookDelta d := by
  simp only [List.mem_singleton, List.mem_cons] at hMem
  rcases hMem with rfl | rfl | rfl | rfl <;> unfold isRookDelta <;> decide

-- Helper: rook deltas are non-zero
private theorem rook_delta_nonzero {df dr : Int}
    (hMem : (df, dr) ∈ [(1, 0), (-1, 0), (0, 1), (0, -1)]) :
    df ≠ 0 ∨ dr ≠ 0 := by
  simp only [List.mem_singleton, List.mem_cons] at hMem
  rcases hMem with ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ <;> decide

theorem mem_slidingTargets_pathClear_rook
    (gs : GameState) (src : Square) (p : Piece) (m : Move)
    (hRook : p.pieceType = PieceType.Rook) :
    m ∈ pieceTargets gs src p →
    pathClear gs.board src m.toSq = true := by
  intro hMem
  unfold pathClear
  rw [List.all_eq_true]
  intro sq hSqMem
  unfold pieceTargets at hMem
  simp only [hRook] at hMem
  -- Get delta info from mem_slidingTargets_exists_delta
  have hDelta := mem_slidingTargets_exists_delta gs src p [(1, 0), (-1, 0), (0, 1), (0, -1)] m hMem
  obtain ⟨df, dr, hDeltaMem, _hFromSq, K, hK_pos, hSqK⟩ := hDelta
  -- Get isRookDelta and isRookMove
  have hRookDelta := rook_deltas_are_rook (df, dr) hDeltaMem
  have hRookMove := mem_pieceTargets_rook_isRookMove gs src p m hRook
    (by unfold pieceTargets; simp only [hRook]; exact hMem)
  -- Get offset j for sq from squaresBetween
  have ⟨j, hj_pos, hj_lt, hSq_j⟩ := mem_squaresBetween_rook_exists_offset hK_pos hRookDelta hSqK hRookMove sq hSqMem
  -- Apply slidingTargets_intermediate_empty
  have hDeltaNonZero := rook_delta_nonzero hDeltaMem
  exact slidingTargets_intermediate_empty gs src p [(1, 0), (-1, 0), (0, 1), (0, -1)] m
    hMem df dr hDeltaMem hDeltaNonZero rook_deltas_unit K hK_pos hSqK j hj_pos hj_lt sq hSq_j

-- Helper: bishop deltas are bishop deltas
private theorem bishop_deltas_are_bishop (d : Int × Int)
    (hMem : d ∈ [(1, 1), (-1, -1), (1, -1), (-1, 1)]) :
    isBishopDelta d := by
  simp only [List.mem_singleton, List.mem_cons] at hMem
  rcases hMem with rfl | rfl | rfl | rfl <;> unfold isBishopDelta <;> decide

-- Helper: bishop deltas are non-zero
private theorem bishop_delta_nonzero {df dr : Int}
    (hMem : (df, dr) ∈ [(1, 1), (-1, -1), (1, -1), (-1, 1)]) :
    df ≠ 0 ∨ dr ≠ 0 := by
  simp only [List.mem_singleton, List.mem_cons] at hMem
  rcases hMem with ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ <;> decide

theorem mem_slidingTargets_pathClear_bishop
    (gs : GameState) (src : Square) (p : Piece) (m : Move)
    (hBishop : p.pieceType = PieceType.Bishop) :
    m ∈ pieceTargets gs src p →
    pathClear gs.board src m.toSq = true := by
  intro hMem
  unfold pathClear
  rw [List.all_eq_true]
  intro sq hSqMem
  unfold pieceTargets at hMem
  simp only [hBishop] at hMem
  -- Get delta info from mem_slidingTargets_exists_delta
  have hDelta := mem_slidingTargets_exists_delta gs src p [(1, 1), (-1, -1), (1, -1), (-1, 1)] m hMem
  obtain ⟨df, dr, hDeltaMem, _hFromSq, K, hK_pos, hSqK⟩ := hDelta
  -- Get isBishopDelta and isDiagonal
  have hBishopDelta := bishop_deltas_are_bishop (df, dr) hDeltaMem
  have hDiagMove := mem_pieceTargets_bishop_isDiagonal gs src p m hBishop
    (by unfold pieceTargets; simp only [hBishop]; exact hMem)
  -- Get offset j for sq from squaresBetween
  have ⟨j, hj_pos, hj_lt, hSq_j⟩ := mem_squaresBetween_bishop_exists_offset hK_pos hBishopDelta hSqK hDiagMove sq hSqMem
  -- Apply slidingTargets_intermediate_empty
  have hDeltaNonZero := bishop_delta_nonzero hDeltaMem
  exact slidingTargets_intermediate_empty gs src p [(1, 1), (-1, -1), (1, -1), (-1, 1)] m
    hMem df dr hDeltaMem hDeltaNonZero bishop_deltas_unit K hK_pos hSqK j hj_pos hj_lt sq hSq_j

-- Helper: queen deltas are queen deltas (rook or bishop)
private theorem queen_deltas_are_queen (d : Int × Int)
    (hMem : d ∈ [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]) :
    isQueenDelta d := by
  simp only [List.mem_singleton, List.mem_cons] at hMem
  rcases hMem with rfl | rfl | rfl | rfl | rfl | rfl | rfl | rfl
  all_goals first | (left; unfold isRookDelta; decide) | (right; unfold isBishopDelta; decide)

-- Helper: queen deltas are non-zero
private theorem queen_delta_nonzero {df dr : Int}
    (hMem : (df, dr) ∈ [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]) :
    df ≠ 0 ∨ dr ≠ 0 := by
  simp only [List.mem_singleton, List.mem_cons] at hMem
  rcases hMem with ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ |
                   ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ <;> decide

-- Helper: queen delta is either rook or bishop
private theorem queen_delta_rook_or_bishop {df dr : Int}
    (hMem : (df, dr) ∈ [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]) :
    isRookDelta (df, dr) ∨ isBishopDelta (df, dr) := by
  simp only [List.mem_singleton, List.mem_cons] at hMem
  rcases hMem with ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ |
                   ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩
  all_goals first | (left; unfold isRookDelta; decide) | (right; unfold isBishopDelta; decide)

theorem mem_slidingTargets_pathClear_queen
    (gs : GameState) (src : Square) (p : Piece) (m : Move)
    (hQueen : p.pieceType = PieceType.Queen) :
    m ∈ pieceTargets gs src p →
    pathClear gs.board src m.toSq = true := by
  intro hMem
  unfold pathClear
  rw [List.all_eq_true]
  intro sq hSqMem
  unfold pieceTargets at hMem
  simp only [hQueen] at hMem
  -- Get delta info from mem_slidingTargets_exists_delta
  have hDelta := mem_slidingTargets_exists_delta gs src p
    [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)] m hMem
  obtain ⟨df, dr, hDeltaMem, _hFromSq, K, hK_pos, hSqK⟩ := hDelta
  have hDeltaNonZero := queen_delta_nonzero hDeltaMem
  -- Check if rook or bishop delta
  have hRookOrBishop := queen_delta_rook_or_bishop hDeltaMem
  rcases hRookOrBishop with hRookDelta | hBishopDelta
  · -- Rook delta case
    have hRookMove := isRookMove_of_rookDelta hRookDelta hK_pos hSqK
    have ⟨j, hj_pos, hj_lt, hSq_j⟩ := mem_squaresBetween_rook_exists_offset hK_pos hRookDelta hSqK hRookMove sq hSqMem
    exact slidingTargets_intermediate_empty gs src p
      [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)] m
      hMem df dr hDeltaMem hDeltaNonZero queen_deltas_unit K hK_pos hSqK j hj_pos hj_lt sq hSq_j
  · -- Bishop delta case
    have hDiagMove := isDiagonal_of_bishopDelta hBishopDelta hK_pos hSqK
    have ⟨j, hj_pos, hj_lt, hSq_j⟩ := mem_squaresBetween_bishop_exists_offset hK_pos hBishopDelta hSqK hDiagMove sq hSqMem
    exact slidingTargets_intermediate_empty gs src p
      [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)] m
      hMem df dr hDeltaMem hDeltaNonZero queen_deltas_unit K hK_pos hSqK j hj_pos hj_lt sq hSq_j

end Rules
end Chess
