import Chess.Spec
import Chess.ParsingProofs
import Chess.SemanticSlidingGeometryLemmas
import Chess.SemanticSlidingPathClearLemmas

namespace Chess
namespace Rules

-- These proofs show that moves generated by pieceTargets respect the geometry requirements
-- (correct movement pattern AND path clearance).

-- For rook: respectsGeometry = isRookMove ∧ pathClear
theorem respectsGeometry_of_pieceTargets_rook
    (gs : GameState) (src : Square) (p : Piece) (m : Move)
    (hRook : p.pieceType = PieceType.Rook) :
    m ∈ pieceTargets gs src p →
    respectsGeometry gs m := by
  intro hMem
  unfold respectsGeometry
  -- Get m.piece = p from slidingTargets structure
  have h_piece : m.piece = p := by
    unfold pieceTargets at hMem
    simp only [hRook] at hMem
    exact mem_slidingTargets_piece_eq gs src p [(1, 0), (-1, 0), (0, 1), (0, -1)] m hMem
  simp only [h_piece, hRook]
  constructor
  · -- isRookMove: use mem_pieceTargets_rook_isRookMove
    have h_isRook := mem_pieceTargets_rook_isRookMove gs src p m hRook hMem
    have h_from : m.fromSq = src := by
      unfold pieceTargets at hMem
      simp only [hRook] at hMem
      have hDelta := mem_slidingTargets_exists_delta gs src p [(1, 0), (-1, 0), (0, 1), (0, -1)] m hMem
      exact hDelta.choose_spec.choose_spec.2.1
    rw [h_from]
    exact h_isRook
  · -- pathClear: use mem_slidingTargets_pathClear_rook
    have h_from : m.fromSq = src := by
      unfold pieceTargets at hMem
      simp only [hRook] at hMem
      have hDelta := mem_slidingTargets_exists_delta gs src p [(1, 0), (-1, 0), (0, 1), (0, -1)] m hMem
      exact hDelta.choose_spec.choose_spec.2.1
    rw [h_from]
    exact mem_slidingTargets_pathClear_rook gs src p m hRook hMem

-- For bishop: respectsGeometry = isDiagonal ∧ pathClear
theorem respectsGeometry_of_pieceTargets_bishop
    (gs : GameState) (src : Square) (p : Piece) (m : Move)
    (hBishop : p.pieceType = PieceType.Bishop) :
    m ∈ pieceTargets gs src p →
    respectsGeometry gs m := by
  intro hMem
  unfold respectsGeometry
  have h_piece : m.piece = p := by
    unfold pieceTargets at hMem
    simp only [hBishop] at hMem
    exact mem_slidingTargets_piece_eq gs src p [(1, 1), (-1, -1), (1, -1), (-1, 1)] m hMem
  simp only [h_piece, hBishop]
  constructor
  · -- isDiagonal: use mem_pieceTargets_bishop_isDiagonal
    have h_isDiag := mem_pieceTargets_bishop_isDiagonal gs src p m hBishop hMem
    have h_from : m.fromSq = src := by
      unfold pieceTargets at hMem
      simp only [hBishop] at hMem
      have hDelta := mem_slidingTargets_exists_delta gs src p [(1, 1), (-1, -1), (1, -1), (-1, 1)] m hMem
      exact hDelta.choose_spec.choose_spec.2.1
    rw [h_from]
    exact h_isDiag
  · -- pathClear: use mem_slidingTargets_pathClear_bishop
    have h_from : m.fromSq = src := by
      unfold pieceTargets at hMem
      simp only [hBishop] at hMem
      have hDelta := mem_slidingTargets_exists_delta gs src p [(1, 1), (-1, -1), (1, -1), (-1, 1)] m hMem
      exact hDelta.choose_spec.choose_spec.2.1
    rw [h_from]
    exact mem_slidingTargets_pathClear_bishop gs src p m hBishop hMem

-- For queen: respectsGeometry = isQueenMove ∧ pathClear = (isRookMove ∨ isDiagonal) ∧ pathClear
theorem respectsGeometry_of_pieceTargets_queen
    (gs : GameState) (src : Square) (p : Piece) (m : Move)
    (hQueen : p.pieceType = PieceType.Queen) :
    m ∈ pieceTargets gs src p →
    respectsGeometry gs m := by
  intro hMem
  unfold respectsGeometry
  have h_piece : m.piece = p := by
    unfold pieceTargets at hMem
    simp only [hQueen] at hMem
    exact mem_slidingTargets_piece_eq gs src p
      [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)] m hMem
  simp only [h_piece, hQueen]
  constructor
  · -- isQueenMove: use mem_pieceTargets_queen_isQueenMove
    have h_isQueen := mem_pieceTargets_queen_isQueenMove gs src p m hQueen hMem
    have h_from : m.fromSq = src := by
      unfold pieceTargets at hMem
      simp only [hQueen] at hMem
      have hDelta := mem_slidingTargets_exists_delta gs src p
        [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)] m hMem
      exact hDelta.choose_spec.choose_spec.2.1
    rw [h_from]
    unfold Movement.isQueenMove
    exact h_isQueen
  · -- pathClear: use mem_slidingTargets_pathClear_queen
    have h_from : m.fromSq = src := by
      unfold pieceTargets at hMem
      simp only [hQueen] at hMem
      have hDelta := mem_slidingTargets_exists_delta gs src p
        [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)] m hMem
      exact hDelta.choose_spec.choose_spec.2.1
    rw [h_from]
    exact mem_slidingTargets_pathClear_queen gs src p m hQueen hMem

end Rules
end Chess
