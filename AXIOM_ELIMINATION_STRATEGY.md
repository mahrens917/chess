# Chess Engine Axiom Elimination Strategy

**Status**: 21 axioms across 3 modules. All tests passing ✓

## Overview

This document provides concrete proof strategies for eliminating all 21 axioms while maintaining the invariant: "zero sorries, all tests passing."

---

## Module 1: Movement.lean (2 axioms)

### 1.1 rookMove_target_at_offset
**Location**: Movement.lean:601
**Type**: Coordinate geometry

**Statement**:
```lean
axiom rookMove_target_at_offset (src tgt : Square) (h : isRookMove src tgt) :
    let (df, dr) := rookDelta src tgt
    let N := rookOffset src tgt
    squareFromInts (src.fileInt + df * N) (src.rankInt + dr * N) = some tgt
```

**Key Insight**:
- For rook moves (horizontal OR vertical only), one of fileDiff/rankDiff is 0
- The offset formula: `signInt(-diff) * |diff| = -diff` reconstructs coordinates
- This is pure integer arithmetic; most suitable for automated provers

**Proof Strategy**:
1. Case split on isRookMove (horizontal vs vertical)
2. In vertical case: fileDiff=0, so `df*N = 0`; prove `rankInt + signInt(-rd)*|rd| = rankInt - rd = tgt.rankInt`
3. In horizontal case: rankDiff=0, so `dr*N = 0`; prove `fileInt + signInt(-fd)*|fd| = fileInt - fd = tgt.fileInt`
4. Apply `squareFromInts_eq_tgt` axiom to conclude

**Dependencies**:
- Lemma: `signInt_mul_natAbs_eq_neg` (arithmetic identity)
- Lemma: `Int.natAbs_of_nonneg`, `Int.natAbs_of_neg` (natAbs properties)
- Axiom: `squareFromInts_eq_tgt` (may be kept - coordinate round-trip)

**Difficulty**: **MEDIUM** - Requires careful Int/Nat conversion handling

---

### 1.2 bishopMove_target_at_offset
**Location**: Movement.lean:609
**Type**: Coordinate geometry (diagonal variant)

**Statement**: Same structure as rookMove, but for diagonals.

**Key Difference**:
- For diagonals: `|fileDiff| = |rankDiff|` (must handle both signs)
- Use this constraint to prove both coordinates update correctly

**Proof Strategy**:
1. Extract constraint: `(fileDiff src tgt).natAbs = (rankDiff src tgt).natAbs` from isDiagonal
2. Prove file coordinate: `fileInt + signInt(-fd)*|fd| = tgt.fileInt`
3. Prove rank coordinate: `rankInt + signInt(-rd)*|rd| = tgt.rankInt` using natAbs equality
4. Both cases now use single natAbs value in offset formula

**Difficulty**: **MEDIUM-HARD** - Extra case analysis for sign handling

---

## Module 2: Rules.lean (4 axioms)

### 2.1 slidingWalk_completeness_aux
**Location**: Rules.lean:723
**Type**: Recursive algorithm property

**Statement**: If intermediate squares are empty and target is at offset N with correct conditions, then `slidingWalk` generates the move.

**Challenge**: Recursive function with accumulator parameter (maxStep, step)
**Proof Strategy**:
1. Structural induction on step (countdown from maxStep to 0)
2. Base case (step=0): acc is returned unchanged; must show move already in acc
3. Inductive case: If step>0, show the recursive call adds move to acc or includes from prior rounds

**Dependency**: Requires strong understanding of fold/accumulator patterns

**Difficulty**: **HARD** - Recursive list construction semantics

---

### 2.2 slidingWalk_generates_target
**Location**: Rules.lean:742
**Type**: Recursive algorithm property (higher-level)

**Statement**: For valid target at offset N with clear path, `slidingWalk` produces the move.

**Proof Strategy**:
1. Apply `slidingWalk_completeness_aux` with appropriate step parameters
2. Show all intermediate squares (1 to N-1) satisfy isEmpty condition
3. Show target at position N satisfies friendly-check condition

**Difficulty**: **MEDIUM-HARD** - Depends on 2.1

---

### 2.3 slidingWalk_mem_foldr_cons
**Location**: Rules.lean:758
**Type**: List operation property

**Statement**: If move is in `foldr` over deltas list, it's also in foldr when adding one more delta to head.

**Proof Strategy**:
1. Apply `List.foldr` definition: prepending to list doesn't remove prior results
2. Use transitivity: if `m ∈ foldr(ds)` then `m ∈ foldr(d::ds)`

**Difficulty**: **EASY-MEDIUM** - Straightforward foldr property

---

### 2.4 slidingWalk_in_slidingTargets
**Location**: Rules.lean:766
**Type**: Membership mapping

**Statement**: If move in `slidingWalk` result for some delta, then in `slidingTargets` when delta is in deltas list.

**Proof Strategy**:
1. Use `slidingTargets` definition: folds over deltas calling `slidingWalk` for each
2. If move generated by `slidingWalk` for (df, dr) ∈ deltas, then appears in final foldr result

**Difficulty**: **EASY-MEDIUM** - Follows from foldr and list membership

---

## Module 3: Spec.lean (15 axioms)

### Group A: Coordinate Conversion (2 axioms)

#### 3A.1 pawnAdvance_squareFromInts
**Location**: Spec.lean:1051
**Type**: Coordinate conversion

**Statement**:
```lean
axiom pawnAdvance_squareFromInts (c : Color) (src tgt : Square) ...
    (rankDiff = -pawnDirection c → squareFromInts(src.file, src.rank + dir) = some tgt) ∧
    (rankDiff = -2*pawnDirection c → squareFromInts(...) = some tgt)
```

**Proof Strategy**: Similar to Movement axioms - use Int arithmetic
**Difficulty**: **MEDIUM**

#### 3A.2 pawnCapture_squareFromInts
**Location**: Spec.lean:1061
**Type**: Coordinate conversion with file offset

**Proof Strategy**: Handle offset in [-1, 1] explicitly
**Difficulty**: **MEDIUM**

---

### Group B: Path Clearance (2 axioms)

#### 3B.1 rookRay_intermediates_empty
**Location**: Spec.lean:494
**Type**: Path validation

**Statement**: For rook move from src to tgt, all intermediate squares are empty.

**Proof Strategy**:
1. Use `squaresBetween` helper function (already in codebase)
2. Prove that `squaresBetween` returns exactly the intermediate squares for rooks
3. Apply board state to show `isEmpty` holds for each

**Dependency**: Analyze `squaresBetween` implementation first

**Difficulty**: **MEDIUM** - List generation property

#### 3B.2 bishopRay_intermediates_empty
**Location**: Spec.lean:506
**Type**: Path validation (diagonal)

**Proof Strategy**: Same as 3B.1 but for diagonals

**Difficulty**: **MEDIUM**

---

### Group C: Pawn Movement Mechanics (5 axioms)

#### 3C.1 pawnAdvance_singleStep_isEmpty
**Location**: Spec.lean:1069
**Type**: Board state property

**Statement**: For single-step pawn advance with pathClear, target square is empty.

**Proof Strategy**:
1. `pathClear` predicate already encodes "target is empty"
2. Unfold `pathClear` definition in Rules.lean
3. Directly follows from definition

**Difficulty**: **EASY** - Likely follows from pathClear definition

#### 3C.2 pawnAdvance_twoStep_isEmpty
**Location**: Spec.lean:1079
**Type**: Board state property

**Statement**: For two-step advance, both intermediate and target are empty.

**Proof Strategy**:
1. Unfold `pathClear` definition for two-step moves
2. Should include checks for intermediate rank and target

**Difficulty**: **EASY-MEDIUM** - Definitions

#### 3C.3 enPassant_not_promo_rank
**Location**: Spec.lean:1113
**Type**: Rank constraint

**Statement**: En passant captures (rank 2 or 5) cannot reach promotion rank (1 or 8).

**Proof Strategy**:
1. Case split on Color (White vs Black)
2. For White: EP on rank 6 (5 0-indexed), promotion rank is 8 (7 0-indexed) → rank ≠ 7 ✓
3. For Black: EP on rank 3 (2 0-indexed), promotion rank is 1 (0 0-indexed) → rank ≠ 0 ✓

**Difficulty**: **TRIVIAL** - Arithmetic on rank values

---

### Group D: En Passant State Invariants (2 axioms - 1 board, 1 pawn)

#### 3D.1 enPassantTarget_rank_constraint
**Location**: Spec.lean:113
**Type**: State invariant

**Statement**: EP target is on rank 2 (Black) or rank 5 (White) only.

**Proof Strategy**:
1. Trace through game initialization: `startingPosition` has `enPassantTarget = none`
2. Trace through `playMove`: EP target set only on 2-square pawn pushes, which occur from ranks 2 and 7
  - White pawn on rank 2 (1 0-indexed) pushes 2 squares → lands on rank 4, so EP target is rank 3 (rank 5 board coordinates)
  - Black pawn on rank 7 (6 0-indexed) pushes 2 squares → lands on rank 5, so EP target is rank 6 (rank 2 board coordinates - wait, check this)

Actually this requires checking `movePiece` logic. Let me note this as requiring implementation analysis.

**Difficulty**: **HARD** - Requires game state machine proof

#### 3D.2 enPassant_target_isEmpty (Spec.lean:121)
**Location**: Spec.lean:121
**Type**: State invariant

**Statement**: EP target square is always empty.

**Proof Strategy**: Similar - trace that EP is only set to the "passed-over" square, which isn't occupied by any piece.

**Difficulty**: **HARD** - Requires game state machine proof

---

### Group E: Move List Membership (2 axioms)

#### 3E.1 pawnAdvance_in_forwardMoves
**Location**: Spec.lean:1122
**Type**: List membership

**Statement**: Given pathClear and advance conditions, move is in forwardMoves list.

**Proof Strategy**:
1. `forwardMoves` is constructed via pattern matching on `squareFromInts` results
2. Show that given conditions, squareFromInts returns some target matching m.toSq
3. Show isEmpty checks pass, so move added to list

**Difficulty**: **MEDIUM** - List construction logic

#### 3E.2 pawnCapture_in_captureMoves
**Location**: Spec.lean:1158
**Type**: List membership

**Proof Strategy**: Similar pattern to 3E.1 but for capture logic

**Difficulty**: **MEDIUM**

---

### Group F: Move Legality Completeness (3 axioms)

#### 3F.1 fideLegal_in_pieceTargets_axiom
**Location**: Spec.lean:224
**Type**: Completeness

**Statement**: Every fideLegal move appears in pieceTargets output.

**Proof Strategy**:
1. Case on piece type (Pawn, Knight, King, Rook, Bishop, Queen)
2. For each type, show pieceTargets function generates all fideLegal destinations
3. Combine piece-specific proofs with main theorem

**Difficulty**: **VERY HARD** - Meta-theorem requiring all piece proofs

#### 3F.2 fideLegal_exact_in_pieceTargets
**Location**: Spec.lean:233
**Type**: Completeness + soundness

**Statement**: Move is in pieceTargets iff it's fideLegal.

**Proof Strategy**: Follows from 3F.1 + soundness of pieceTargets generation

**Difficulty**: **VERY HARD** - Depends on 3F.1

#### 3F.3 castleMoveIfLegal_produces_fideLegal
**Location**: Spec.lean:1005
**Type**: Castling-specific completeness

**Statement**: If castle move is generated, it satisfies fideLegal predicate.

**Proof Strategy**:
1. Analyze `castleMovesIfLegal` function
2. Show its output subset ⊆ {moves satisfying fideLegal}
3. Requires unpacking castling conditions from fideLegal

**Difficulty**: **HARD** - Castling has complex conditions

---

## Recommended Implementation Order

### Phase 1: Trivial to Easy (Foundation)
1. **3C.3** `enPassant_not_promo_rank` - Pure arithmetic ✓
2. **2.3** `slidingWalk_mem_foldr_cons` - Standard foldr property
3. **3C.1** `pawnAdvance_singleStep_isEmpty` - Unfold definitions
4. **3C.2** `pawnAdvance_twoStep_isEmpty` - Definition unfolding

**Estimated effort**: 1-2 hours
**Value**: Proves 4 axioms, clears foundation

---

### Phase 2: Medium Difficulty (Definitions + Arithmetic)
5. **2.4** `slidingWalk_in_slidingTargets` - List membership
6. **3A.1** `pawnAdvance_squareFromInts` - Coordinate Int arithmetic
7. **3A.2** `pawnCapture_squareFromInts` - Offset coordinate handling
8. **3E.1** `pawnAdvance_in_forwardMoves` - Pattern matching + lists
9. **3E.2** `pawnCapture_in_captureMoves` - Same pattern

**Estimated effort**: 3-4 hours
**Value**: Proves 5 axioms, handles pawn coordinate system

---

### Phase 3: Hard - Algorithms (Recursion + Induction)
10. **3B.1** `rookRay_intermediates_empty` - Path validation on lists
11. **3B.2** `bishopRay_intermediates_empty` - Diagonal path validation
12. **2.1** `slidingWalk_completeness_aux` - Recursive list induction
13. **2.2** `slidingWalk_generates_target` - High-level recursive property

**Estimated effort**: 4-6 hours
**Value**: Proves 4 axioms, establishes sliding piece semantics

---

### Phase 4: Very Hard - State Machines (Game invariants)
14. **3D.1** `enPassantTarget_rank_constraint` - Game initialization + playMove tracing
15. **3D.2** `enPassant_target_isEmpty` - Game state preservation

**Estimated effort**: 6-8 hours (requires full playMove analysis)
**Value**: Proves 2 axioms, validates game state correctness

---

### Phase 5: Geometric - Coordinate Proofs (Consider external automation)
16. **1.1** `rookMove_target_at_offset` - Coordinate geometry on rooks
17. **1.2** `bishopMove_target_at_offset` - Coordinate geometry on diagonals

**Estimated effort**: 2-4 hours (or delegate to automated prover)
**Value**: Proves 2 axioms, establishes move target calculation

---

### Phase 6: Meta-Theorems - Move Completeness (Combines everything)
18. **3F.3** `castleMoveIfLegal_produces_fideLegal` - Castling system
19. **3F.1** `fideLegal_in_pieceTargets_axiom` - Move generation completeness
20. **3F.2** `fideLegal_exact_in_pieceTargets` - Equivalence theorem

**Estimated effort**: 8-10 hours (depends on Phases 1-5)
**Value**: Proves 3 axioms, completes move generation correctness

---

## Total Effort Estimate

| Phase | Axioms | Time | Cumulative |
|-------|--------|------|-----------|
| 1 (Trivial) | 4 | 1-2h | 1-2h |
| 2 (Medium) | 5 | 3-4h | 4-6h |
| 3 (Algorithms) | 4 | 4-6h | 8-12h |
| 4 (State machines) | 2 | 6-8h | 14-20h |
| 5 (Geometry) | 2 | 2-4h | 16-24h |
| 6 (Meta) | 3 | 8-10h | 24-34h |
| **Total** | **21** | - | **~30 hours** |

---

## Critical Success Factors

1. **Maintain test suite passing** - Every phase should verify with `lake test`
2. **Prove in order** - Later phases depend on earlier ones
3. **Document dependencies** - Mark which axioms unblock others
4. **Use external tools** - Geometry proofs (Phase 5) suitable for automated provers
5. **Test each locally** - Build incrementally with `lake build` validation

---

## Key Lemmas to Extract

These should be proven first to support multiple axiom proofs:

```lean
-- Arithmetic
lemma signInt_mul_natAbs_eq_neg (x : Int) : signInt (-x) * (x.natAbs : Int) = -x
lemma natAbs_eq_iff_abs_eq (x y : Int) : x.natAbs = y.natAbs ↔ absInt x = absInt y

-- List operations
lemma foldr_cons_mem {α : Type*} (a : α) (f : α → List α → List α) (as : List α) (x : α) :
    x ∈ f a (as.foldr f []) → x ∈ as.foldr f []

-- Square operations
lemma squareFromInts_round_trip (s : Square) :
    squareFromInts s.fileInt s.rankInt = some s
```

---

## References

- **FIDE Laws**: Move legality (https://www.fide.com/FIDE/handbook/LawsOfChess.pdf)
- **PGN Specification**: Move notation
- **Lean 4 Stdlib**: List, Int, Vector operations
